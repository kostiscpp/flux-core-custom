/************************************************************\
 * Copyright 2023 Lawrence Livermore National Security, LLC
 * (c.f. AUTHORS, NOTICE.LLNS, COPYING)
 *
 * This file is part of the Flux resource manager framework.
 * For details, see https://github.com/flux-framework.
 *
 * SPDX-License-Identifier: LGPL-3.0
\************************************************************/

/* cert.c - manage zeromq curve certificates
 *
 * Note that ZeroMQ curve certs generated by CZMQ use the ZPL config
 * format.  Flux no longer uses CZMQ but retains compatibility with certs
 * generated by earlier Flux versions that did.  Although Flux certs remain
 * in ZPL form, this cert parser is far more restrictive, and therefore
 * simpler, than the generic ZPL parser in CZMQ.
 */


#if HAVE_CONFIG_H
#include "config.h"
#endif
#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <zmq.h>
#include <string.h>

#include "src/common/libutil/errno_safe.h"
#include "src/common/libutil/strstrip.h"
#ifndef HAVE_STRLCPY
#include "src/common/libmissing/strlcpy.h"
#endif
#include "src/common/libczmqcontainers/czmq_containers.h"
#include "ccan/str/str.h"

#include "sockopt.h"
#include "cert.h"

/* CURVEZMQ public and private long-term keys are always exactly 32 octets.
 * See 0MQ RFC 26/CURVEZMQ (https://rfc.zeromq.org/spec/26/)
 */
#define KEYSIZE 32
#define TXTSIZE 41 // Z85-encoded key size + \0

struct cert {
    uint8_t public_key[KEYSIZE];
    uint8_t secret_key[KEYSIZE];
    char public_txt[TXTSIZE];
    char secret_txt[TXTSIZE];
    zhash_t *metadata;
    bool secret_valid;
    bool public_valid;
};

void cert_destroy (struct cert *cert)
{
    if (cert) {
        int saved_errno = errno;
        zhash_destroy (&cert->metadata);
        free (cert);
        errno = saved_errno;
    }
}

static struct cert *cert_create_empty (void)
{
    struct cert *cert;
    printf("cert_create_empty before calloc\n");
    if (!(cert = calloc (1, sizeof (*cert))))
        return NULL;
    printf("cert_create_empty after calloc\n");
    if (!(cert->metadata = zhash_new ())) {
        errno = ENOMEM;
        goto error;
    }
    printf("cert_create_empty after zhash_new()\n");
    zhash_autofree (cert->metadata);
    printf("cert_create_empty after zhash_autofree\n");
    return cert;
error:
    cert_destroy (cert);
    return NULL;
}

struct cert *cert_create (void)
{
    struct cert *cert;
    printf("got to cert_create\n");
    if (!(cert = cert_create_empty ()))
        goto error;
    printf("got pass cert_create_empty\n");
    if (zmq_curve_keypair (cert->public_txt, cert->secret_txt) < 0)
        goto error;
    printf("passed zmq_curve_keypair\n");
    if (!zmq_z85_decode (cert->public_key, cert->public_txt)
        || !zmq_z85_decode (cert->secret_key, cert->secret_txt)) {
        errno = EINVAL;
        goto error;
    }
    printf("passed decodes\n");
    cert->public_valid = true;
    cert->secret_valid = true;
    return cert;
error:
    printf("something went wrong and went to the error tag\n");
    cert_destroy (cert);
    printf("cert destroyed\n");
    return NULL;
}

static int copy_z85_key (char *dst, const char *src, int size)
{
    const char *xtra = ".-:+=^!/*?&<>()[]{}@%$#";
    const char *cp = src;

    if (!cp || strlen (cp) != size - 1)
        return -1;
    while (*cp) {
        if (!isalnum (*cp) && !strchr (xtra, *cp))
            return -1;
        cp++;
    }
    (void)strlcpy (dst, src, size);
    return 0;
}

// assumes both keys are valid
static bool valid_keypair (struct cert *cert)
{
#if (ZMQ_VERSION >= ZMQ_MAKE_VERSION(4,2,1))
    char pub[TXTSIZE];
    if (zmq_curve_public (pub, cert->secret_txt) < 0
        || !streq (pub, cert->public_txt))
        return false;
#endif
    return true;
}

struct cert *cert_create_from (const char *public_txt, const char *secret_txt)
{
    struct cert *cert;

    if (!(cert = cert_create_empty ()))
        return NULL;
    if (public_txt) {
        if (copy_z85_key (cert->public_txt, public_txt, TXTSIZE) < 0
            || !zmq_z85_decode (cert->public_key, cert->public_txt))
            goto inval;
        cert->public_valid = true;
    }
    if (secret_txt) {
        if (copy_z85_key (cert->secret_txt, secret_txt, TXTSIZE) < 0
            || !zmq_z85_decode (cert->secret_key, cert->secret_txt))
            goto inval;
        cert->secret_valid = true;
    }
    if (cert->public_valid && cert->secret_valid) {
        if (!valid_keypair (cert))
            goto inval;
    }
    return cert;
inval:
    errno = EINVAL;
    cert_destroy (cert);
    return NULL;
}

int cert_meta_set (struct cert *cert, const char *key, const char *val)
{
    if (!cert || !key || strlen (key) == 0 || !val) {
        errno = EINVAL;
        return -1;
    }
    if (zhash_insert (cert->metadata, key, (void *)val) < 0) {
        errno = EEXIST;
        return -1;
    }
    return 0;
}

const char *cert_meta_get (struct cert *cert, const char *name)
{
    if (!cert || !name)
        return NULL;
    return zhash_lookup (cert->metadata, name);
}

static bool meta_equal (zhash_t *meta1, zhash_t *meta2)
{
    char *val1;
    char *val2;

    if (zhash_size (meta1) != zhash_size (meta2))
        return false;
    val1 = zhash_first (meta1);
    while (val1) {
        val2 = zhash_lookup (meta2, zhash_cursor (meta1));
        if (!val2 || !streq (val1, val2))
            return false;
        val1 = zhash_next (meta1);
    }
    return true;
}

const char *cert_public_txt (struct cert *cert)
{
    return (cert && cert->public_valid) ? cert->public_txt : NULL;
}

const char *cert_secret_txt (struct cert *cert)
{
    return (cert && cert->secret_valid) ? cert->secret_txt : NULL;
}

bool cert_equal (struct cert *c1, struct cert *c2)
{
    if (!c1
        || !c2
        || c1->public_valid != c2->public_valid
        || c1->secret_valid != c2->secret_valid
        || !meta_equal (c1->metadata, c2->metadata))
        return false;
    if (c1->public_valid) {
        if (memcmp (c1->public_key, c2->public_key, KEYSIZE) != 0)
            return false;
    }
    if (c1->secret_valid) {
        if (memcmp (c1->secret_key, c2->secret_key, KEYSIZE) != 0)
            return false;
    }
    return true;
}

// File format is compatible with CZMQ zcert, which uses ZPL (0MQ RFC 4).
int cert_write (struct cert *cert, FILE *f)
{
    const char *entry;

    if (!cert || !cert->public_valid || !cert->secret_valid || !f) {
        errno = EINVAL;
        return -1;
    }
    if (fprintf (f,
                 "#  ZeroMQ CURVE **Secret** Certificate\n"
                 "#  DO NOT DISTRIBUTE\n"
                 "\n"
                 "metadata\n") < 0)
        return -1;
    entry = zhash_first (cert->metadata);
    while (entry) {
        if (fprintf (f,
                     "    %s = \"%s\"\n",
                     zhash_cursor (cert->metadata),
                     entry) < 0)
            return -1;
        entry = zhash_next (cert->metadata);
    }
    if (fprintf (f,
                 "curve\n"
                 "    public-key = \"%s\"\n"
                 "    secret-key = \"%s\"\n",
                 cert->public_txt,
                 cert->secret_txt) < 0)
        return -1;
    return 0;
}

// "val" => val (modifies s)
static char *parse_quoted (char *s)
{
    size_t len = strlen (s);
    if (len < 2)
        return NULL;
    if (s[0] != '"' || s[len - 1] != '"')
        return NULL;
    s[len - 1] = '\0';
    memmove (&s[0], &s[1], len - 1);
    return s;
}

static bool valid_key (const char *s)
{
    const char *xtra = "-.";
    const char *cp = s;

    if (!cp || strlen (cp) == 0)
        return false;
    while (*cp) {
        if (!isalnum (*cp) && !strchr (xtra, *cp))
            return false;
        cp++;
    }
    return true;
}

static bool valid_value (const char *s)
{
    const char *xtra = ".-:+=^!/*?&<>()[]{}@%$# \t";
    const char *cp = s;

    if (!cp)
        return false;
    while (*cp) {
        if (!isalnum (*cp) && !strchr (xtra, *cp))
            return false;
        cp++;
    }
    return true;
}

// parse key = "val" (modifies 's')
static int parse_keyval (char *s, const char **keyp, const char **valp)
{
    char *key = s;
    char *val;

    if (!(val = strchr (s, '=')))
        goto error;
    *val++ = '\0';
    key = strstrip (key);
    if (!valid_key (key))
        goto error;
    val = parse_quoted (strstrip (val));
    if (!valid_value (val)) {
        goto error;
    }
    *keyp = key;
    *valp = val;
    return 0;
error:
    errno = EINVAL;
    return -1;
}

// modifies 's'
static int parse_metadata (struct cert *cert, char *s)
{
    const char *key;
    const char *val;

    if (parse_keyval (s, &key, &val) < 0)
        return -1;
    if (zhash_insert (cert->metadata, key, (void *)val) < 0) {
        errno = EEXIST;
        return -1;
    }
    return 0;
}

// modifies 's'
static int parse_curve (struct cert *cert, char *s)
{
    const char *key;
    const char *val;

    if (parse_keyval (s, &key, &val) < 0)
        return -1;
    if (streq (key, "public-key")) {
        if (copy_z85_key (cert->public_txt, val, TXTSIZE) < 0
            || !zmq_z85_decode (cert->public_key, cert->public_txt))
            goto error;
        cert->public_valid = true;
    }
    else if (streq (key, "secret-key")) {
        if (copy_z85_key (cert->secret_txt, val, TXTSIZE) < 0
            || !zmq_z85_decode (cert->secret_key, cert->secret_txt))
            goto error;
        cert->secret_valid = true;
    }
    else
        goto error;
    return 0;
error:
    errno = EINVAL;
    return -1;
}

// Parse the certificate as we've been previously generating them in Flux
// with CZMQ zcert_t.  This is obviously not a general ZPL parser.
struct cert *cert_read (FILE *f)
{
    struct cert *cert;
    char buf[256];
    const char *section = "none";
    char *line;

    if (!f) {
        errno = EINVAL;
        return NULL;
    }
    if (!(cert = cert_create_empty ()))
        return NULL;
    while ((line = fgets (buf, sizeof (buf), f))) {
        if (strlen (line) == 0)
            continue;
        bool indent = (line[0] == ' ' || line[0] == '\t' ) ? true : false;
        /* Discard comments and skip blank lines.
         * Strip leading and trailing white space.
         */
        char *stripped = strstrip (line);
        if (strlen (stripped) == 0 || stripped[0] == '#')
            continue;

        /* There are two possible sections: metadata and curve.
         * Everything else is a key = "value" pair.
         */
        if (!indent && streq (stripped, "metadata"))
            section = "metadata";
        else if (!indent && streq (stripped, "curve")) {
            section = "curve";
        }
        else if (indent && streq (section, "metadata")) {
            if (parse_metadata (cert, stripped) < 0)
                goto error;
        }
        else if (indent && streq (section, "curve")) {
            if (parse_curve (cert, stripped) < 0)
                goto error;
        }
        else
            goto inval;
    }
    if (ferror (f))
        goto error;
    if (!cert->public_valid || !cert->secret_valid
        || !valid_keypair (cert))
        goto inval;
    return cert;
inval:
    errno = EINVAL;
error:
    cert_destroy (cert);
    return NULL;
}

int cert_apply (struct cert *cert, void *sock)
{
    if (!cert || !cert->public_valid || !cert->secret_valid) {
        errno = EINVAL;
        return -1;
    }
    if (zmq_setsockopt (sock,
                        ZMQ_CURVE_PUBLICKEY,
                        cert->public_key,
                        KEYSIZE) < 0
        || zmq_setsockopt (sock,
                           ZMQ_CURVE_SECRETKEY,
                           cert->secret_key,
                           KEYSIZE) < 0)
        return -1;
    return 0;
}

// vi:ts=4 sw=4 expandtab
